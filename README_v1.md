# README_v1 - Nios II + SimpleMLP 实现路线（v1）

> **状态**：✅ 已完成 / Legacy
> **架构**：Nios II 软核 + SimpleMLP（多层感知机）
> **推理时间**：14 ms @ 50 MHz
> **当前主线**：[v1.1](hardware/src/v1.1/) - 纯 Verilog + TinyLeNet（卷积神经网络）

---

## 📋 目录

1. [技术路线说明](#技术路线说明)
2. [架构概述](#架构概述)
3. [SimpleMLP 模型](#simplemlp-模型)
4. [资源占用](#资源占用)
5. [性能表现](#性能表现)
6. [优势与限制](#优势与限制)
7. [目录结构](#目录结构)
8. [技术经验](#技术经验)

---

## 技术路线说明

本项目探索了两种不同的 FPGA 实现路线：

| 版本 | 硬件架构 | 神经网络模型 | 推理方式 | 状态 |
|------|---------|------------|---------|------|
| **v1** | Nios II 软核 | SimpleMLP（全连接） | C 语言串行推理 | ✅ 已完成 |
| **v1.1** | 纯 Verilog RTL | TinyLeNet（卷积） | 硬件并行加速 | ✅ 已完成 |

**关键差异**：
- **v1** 使用软核处理器，适合快速原型开发
- **v1.1** 使用专用硬件，追求极致性能与资源利用

**重要说明**：两个版本使用不同的神经网络架构，**性能不具备直接可比性**。

---

## 架构概述

### 系统框图

```
┌─────────────────────────────────────────────────────────────┐
│                    FPGA (EP4CE10)                           │
│                                                             │
│  ┌───────────────────────────────────────────────────┐     │
│  │              Nios II System (Qsys)                │     │
│  │                                                   │     │
│  │  ┌─────────────┐    ┌──────────────┐             │     │
│  │  │  Nios II/f  │───→│  On-Chip RAM │             │     │
│  │  │  Processor  │    │   (32 KB)    │             │     │
│  │  └─────────────┘    └──────────────┘             │     │
│  │         │                    │                   │     │
│  │         ├────────────────────┴───────┐           │     │
│  │         │                            │           │     │
│  │  ┌──────▼──────┐            ┌───────▼──────┐    │     │
│  │  │ UART (JTAG) │            │   GPIO       │    │     │
│  │  └─────────────┘            └──────────────┘    │     │
│  └───────┬─────────────────────────────┬───────────┘     │
│          │                             │                 │
│  ┌───────▼──────┐              ┌───────▼──────┐          │
│  │   UART RX    │              │  7-Seg LED   │          │
│  │   (Serial)   │              │  (74HC595)   │          │
│  └──────────────┘              └──────────────┘          │
└─────────────────────────────────────────────────────────────┘
         ▲                                ▼
         │                                │
    [PC 发送图像]                   [数码管显示结果]
```

### 核心组件

| 组件 | 说明 | 资源占用（实测） |
|------|------|-----------------|
| **Nios II/f** | 快速型软核处理器（性能最强） | ~700 LEs |
| **On-Chip RAM** | 代码与数据存储（32 KB） | 8 × M9K 块 |
| **UART** | 串口通信（115200 bps） | ~100 LEs |
| **GPIO** | 数码管驱动 | ~50 LEs |
| **自定义外设** | 数码管控制器 | ~200 LEs |

**内存分配**（32 KB On-Chip RAM）：
- 代码段（.text）：~10 KB
- 数据段（.data/.bss）：~2 KB
- 堆栈（stack/heap）：~4 KB
- SimpleMLP 权重：~25 KB（784×32 + 32×10 ≈ 25,408 字节）
- 特征缓存：~0.5 KB（输入 784 + 隐层 32 + 输出 10）

---

## SimpleMLP 模型

### 网络结构

v1 版本使用 **SimpleMLP**（多层感知机），这是一个简单的两层全连接网络：

```
输入层 (784)
    ↓
全连接层 1: 784 → 32
    ↓
ReLU 激活
    ↓
全连接层 2: 32 → 10
    ↓
输出层 (10 classes)
```

**与 TinyLeNet 的对比**：

| 特性 | SimpleMLP (v1) | TinyLeNet (v1.1) |
|------|---------------|------------------|
| **网络类型** | 全连接（MLP） | 卷积神经网络（CNN） |
| **层数** | 2 层 | 4 层（2 卷积 + 2 全连接） |
| **参数量** | ~25 KB | ~150 KB |
| **准确率** | ~95-96% | ~99% |
| **计算复杂度** | 低（仅矩阵乘法） | 高（卷积 + 池化 + 全连接） |

**选择 SimpleMLP 的原因**：
- ✅ **内存友好**：25 KB 权重可完全放入 32 KB RAM
- ✅ **计算简单**：两层全连接，适合 CPU 串行计算
- ✅ **快速开发**：网络结构简单，易于 C 语言实现
- ⚠️ **精度较低**：相比 CNN，准确率略低（95% vs 99%）

### 模型定义（Python）

```python
# model_tools/models/SimpleMLP.py
import torch.nn as nn

HIDDEN_SIZE = 32  # 隐层节点数

class SimpleMLP(nn.Module):
    def __init__(self):
        super(SimpleMLP, self).__init__()
        self.flatten = nn.Flatten()
        # Layer 1: 784 → 32
        self.fc1 = nn.Linear(28 * 28, HIDDEN_SIZE)
        self.relu = nn.ReLU()
        # Layer 2: 32 → 10
        self.fc2 = nn.Linear(HIDDEN_SIZE, 10)

    def forward(self, x):
        x = self.flatten(x)
        x = self.fc1(x)
        x = self.relu(x)
        x = self.fc2(x)
        return x
```

### 软件实现（C 伪代码）

```c
// Nios II 上的 SimpleMLP 推理
int8_t weights_fc1[784][32];   // 第一层权重
int8_t weights_fc2[32][10];    // 第二层权重
int32_t bias_fc1[32];          // 第一层偏置
int32_t bias_fc2[10];          // 第二层偏置

void inference(uint8_t image[784], int8_t result[10]) {
    // 1. 全连接层 1: 784 → 32
    int32_t hidden[32];
    for (int i = 0; i < 32; i++) {
        int64_t acc = bias_fc1[i];
        for (int j = 0; j < 784; j++) {
            acc += image[j] * weights_fc1[j][i];
        }
        // 量化并应用 ReLU
        hidden[i] = quantize_and_relu(acc);
    }

    // 2. 全连接层 2: 32 → 10
    for (int i = 0; i < 10; i++) {
        int64_t acc = bias_fc2[i];
        for (int j = 0; j < 32; j++) {
            acc += hidden[j] * weights_fc2[j][i];
        }
        result[i] = quantize(acc);
    }
}
```

---

## 资源占用

### FPGA 资源统计

| 资源类型 | 使用量 | EP4CE10 总量 | 利用率 |
|---------|--------|--------------|--------|
| **逻辑单元 (LCs)** | ~1,550 | 10,320 | **15.0%** |
| **M9K 存储块** | 8 | 46 | **17.4%** |
| **嵌入式乘法器** | 0 | 23 | 0% |

**资源分配明细**：
- Nios II/f 处理器：~700 LEs
- On-Chip RAM（32 KB）：8 × M9K
- UART 模块：~100 LEs
- GPIO + 数码管：~250 LEs
- Qsys 互连总线：~500 LEs

**关键观察**：
- ✅ **资源占用低**：仅 15% LCs，剩余 85% 可用于其他功能
- ✅ **内存适配**：32 KB RAM 接近 EP4CE10 的 On-Chip RAM 极限（414 Kbits ≈ 51.75 KB）
- ⚠️ **无硬件加速**：未使用 DSP 乘法器（软件实现乘法）

---

## 性能表现

### 推理性能

| 指标 | 数值 | 备注 |
|------|------|------|
| **推理延迟** | **14 ms** | 单张图像，50 MHz |
| **吞吐率** | ~71 FPS | 1000 / 14 |
| **周期数** | ~700,000 | 14 ms × 50 MHz |

**计算周期分析**：
```
FC1 计算: 784 × 32 = 25,088 次乘加
FC2 计算: 32 × 10 = 320 次乘加
总乘加:   25,408 次

假设每次乘加 20 周期（软核软件实现）:
25,408 × 20 ≈ 508,160 周期

加上量化、ReLU、内存访问:
~700,000 周期 ≈ 14 ms @ 50 MHz
```

### 准确率

| 数据集 | 准确率 | 备注 |
|--------|--------|------|
| **训练集** | ~96% | 60,000 张 |
| **测试集** | ~95% | 10,000 张 |

**注**：相比 TinyLeNet（99%），SimpleMLP 准确率较低，但对于快速原型验证已足够。

---

## 优势与限制

### Nios II + SimpleMLP 方案的优势 ✅

#### 1. **快速开发** 🚀
- **C 语言编程**：开发周期短，无需深入 RTL 设计
- **Eclipse IDE**：熟悉的开发环境，支持 printf 调试
- **模块化代码**：易于理解和维护

#### 2. **灵活调整** 🔧
- **算法迭代**：修改推理逻辑只需重新编译 C 代码（秒级）
- **无需重新综合**：软件修改不影响硬件，节省综合时间（数十分钟）
- **参数调优**：轻松尝试不同的量化策略

#### 3. **低资源占用** 📊
- **15% LCs**：剩余 85% 可用于其他功能
- **SimpleMLP 小巧**：仅需 25 KB 权重，适合小容量 RAM

#### 4. **调试友好** 🐛
- **printf 输出**：实时查看中间结果
- **软件断点**：Eclipse 支持单步调试
- **快速定位问题**：软件调试比波形分析更直观

#### 5. **性能可接受** ⚡
- **14 ms 推理**：满足大部分非实时应用
- **~71 FPS**：足够用于视频流处理（30 FPS）
- **低功耗**：50 MHz 主频，功耗适中

### 方案限制 ⚠️

#### 1. **内存接近极限** 💾
- **32 KB RAM**：接近 EP4CE10 的 On-Chip RAM 上限
- **无扩展空间**：难以支持更大的网络（如 TinyLeNet）
- **外部 SDRAM**：可扩展，但增加复杂度与延迟

#### 2. **准确率较低** 📉
- **SimpleMLP: ~95%**：相比 TinyLeNet（99%）低 4%
- **无卷积层**：丢失空间特征提取能力
- **仅适用简单任务**：复杂图像识别能力有限

#### 3. **性能受限于 CPU** 🐌
- **软件乘法**：未使用 DSP，每次乘法多个周期
- **串行计算**：无法并行化矩阵运算
- **频率限制**：50 MHz 受 Nios II 时序约束

#### 4. **不适合扩展** 🚫
- **更复杂网络**：卷积层难以高效实现
- **批处理**：内存不足以支持多图并行
- **实时性要求**：14 ms 对于某些应用仍偏慢

---

## 目录结构

```
hardware/src/v1/  (Nios II + SimpleMLP 版本)
├── hardware/
│   ├── mnist_nios.v          # Qsys 生成的顶层（包含 Nios II）
│   ├── IPcore/               # PLL 等 IP 核
│   │   ├── clk_pll.v
│   │   ├── clk_pll_bb.v
│   │   └── clk_pll_inst.v
│   └── seg/                  # 数码管驱动模块（可复用）
│       ├── seg_595_dynamic.v
│       ├── hc595_ctrl.v
│       ├── seg_dynamic.v
│       └── bcd_8421.v
├── software/                 # Nios II C 代码
│   ├── main.c                # 主程序（推理循环）
│   ├── SimpleMLP.c           # SimpleMLP 推理实现
│   ├── weights.h             # 权重数据（嵌入）
│   └── uart.c                # UART 通信驱动
└── README.md                 # 简要说明
```

---

## 技术经验

### 成功经验 ✅

#### 1. **模块化外设设计**
v1 中的数码管驱动模块在 v1.1 中完全复用：
- ✅ `seg_595_dynamic.v` - 数码管驱动
- ✅ `hc595_ctrl.v` - 74HC595 控制器
- ✅ `bcd_8421.v` - BCD 译码器

**启示**：良好的模块化设计可跨版本复用，节省开发时间。

#### 2. **SimpleMLP 的合理选择**
- ✅ 25 KB 权重适配 32 KB RAM
- ✅ 计算简单，适合 CPU 串行推理
- ✅ 开发周期短，快速验证方案可行性

**启示**：选择合适的网络架构比盲目追求复杂度更重要。

#### 3. **C 语言快速原型**
- ✅ 推理逻辑清晰，易于调试
- ✅ 为 v1.1 的 Python 参考模型（`hw_ref.py`）提供思路
- ✅ 验证了 INT8 定点数的可行性

**启示**：C 语言原型是硬件实现的良好过渡。

### 教训与启发 📝

#### 1. **内存规划至关重要**
- ⚠️ 32 KB RAM 接近极限，缺乏扩展空间
- 💡 **经验**：提前规划内存分配，预留 20-30% 余量

#### 2. **软核 vs 硬件加速的权衡**
- ⚠️ Nios II 适合控制逻辑，不适合计算密集任务
- 💡 **经验**：混合架构（Nios II 控制 + 硬件加速器计算）可能是最优解

#### 3. **SimpleMLP vs CNN 的精度差距**
- ⚠️ 4% 精度差距在某些应用中不可接受
- 💡 **经验**：准确率要求 > 97% 时，必须使用 CNN

#### 4. **On-Chip RAM 的局限性**
- ⚠️ EP4CE10 的 RAM 容量限制了网络规模
- 💡 **解决方案**：
  - 使用外部 SDRAM（增加复杂度）
  - 迁移到更大 FPGA（Cyclone V）
  - 采用纯硬件加速（v1.1 路线）

---

## 适用场景

### Nios II + SimpleMLP 适合的场景 ✅

1. **快速原型验证**
   - 需求：验证算法可行性，快速迭代
   - 优势：C 语言开发快，调试友好

2. **资源受限但准确率要求不高**
   - 需求：95% 准确率可接受
   - 优势：15% LCs，剩余资源可用于其他功能

3. **教学与学习**
   - 需求：理解神经网络推理原理
   - 优势：代码简洁易懂，适合入门

4. **混合架构的控制部分**
   - 需求：Nios II 负责控制，硬件加速器负责计算
   - 优势：软硬协同，各取所长

### 不适合的场景 ❌

1. **高准确率要求**（>97%）
   - SimpleMLP 准确率 ~95%，无法满足
   - **建议**：使用 CNN（TinyLeNet）

2. **实时性要求严格**（<10 ms）
   - 14 ms 延迟无法满足
   - **建议**：使用硬件加速

3. **复杂网络**（卷积、池化等）
   - CPU 实现卷积效率低
   - **建议**：专用硬件加速器

4. **批处理**（多图并行推理）
   - 32 KB RAM 不足以缓存多张图像
   - **建议**：外部 SDRAM 或更大 FPGA

---

## 结论

Nios II + SimpleMLP 方案（v1）是一次成功的技术探索，它证明了：

1. ✅ **在入门级 FPGA 上实现神经网络推理是可行的**
2. ✅ **Nios II 软核适合快速原型开发与灵活调试**
3. ✅ **SimpleMLP 在资源受限条件下是合理选择**
4. ✅ **14 ms 推理时间对于大部分非实时应用已足够**

**v1 与 v1.1 的关系**：
- **v1**：快速原型，验证软件流程，探索 Nios II 可行性
- **v1.1**：极致优化，追求性能与资源利用率，探索硬件加速

两个版本不是竞争关系，而是**互补的技术探索路径**。

---

## 参考资料

### 相关文档
- [v1.1 纯 Verilog 实现](hardware/src/v1.1/README.md)
- [SimpleMLP 模型定义](model_tools/models/SimpleMLP.py)
- [主 README](README.md)

### 技术文档
- [Nios II 处理器官方文档](https://www.intel.com/content/www/us/en/docs/programmable/683632/current/nios-ii-processor.html)
- [Qsys 系统集成工具](https://www.intel.com/content/www/us/en/docs/programmable/683440/current/introduction-to.html)
- [Eclipse Nios II 软件开发](https://www.intel.com/content/www/us/en/docs/programmable/683525/current/getting-started-with-the-graphical-user.html)

---

**文档版本**：v2.0（已更正）
**最后更新**：2026-01-04
**状态**：✅ 已完成（Legacy，仅供参考）
