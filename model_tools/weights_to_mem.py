#!/usr/bin/env python3
"""
Convert exported model weights (C header) into .mem/.mif files and Verilog ROM wrappers.
"""

from __future__ import annotations

import argparse
import os
import re
from dataclasses import dataclass
from typing import List, Optional, Sequence


TYPE_WIDTHS = {
    "int8_t": 8,
    "uint8_t": 8,
    "int16_t": 16,
    "uint16_t": 16,
    "int32_t": 32,
    "uint32_t": 32,
}

ARRAY_DECL_RE = re.compile(
    r"static\s+const\s+(?P<ctype>[a-zA-Z0-9_]+)\s+"
    r"(?P<name>[A-Za-z_]\w*)\s*(?P<dims>(\[[^\]]*\])*)\s*=\s*\{",
    re.M,
)


@dataclass
class ArrayDef:
    name: str
    ctype: str
    dims: Optional[List[int]]
    values: List[int]


def strip_comments(text: str) -> str:
    text = re.sub(r"/\*.*?\*/", "", text, flags=re.S)
    text = re.sub(r"//.*", "", text)
    return text


def extract_braced(text: str, start_idx: int) -> tuple[str, int]:
    depth = 0
    for i in range(start_idx, len(text)):
        ch = text[i]
        if ch == "{":
            depth += 1
        elif ch == "}":
            depth -= 1
            if depth == 0:
                return text[start_idx : i + 1], i + 1
    raise ValueError("Unbalanced braces in initializer")


def parse_dims(dims_text: str) -> Optional[List[int]]:
    if not dims_text:
        return None
    tokens = re.findall(r"\[(\d*)\]", dims_text)
    if not tokens:
        return None
    dims: List[int] = []
    for tok in tokens:
        if tok == "":
            return None
        dims.append(int(tok))
    return dims


def product(nums: Sequence[int]) -> int:
    result = 1
    for n in nums:
        result *= n
    return result


def parse_arrays(text: str) -> List[ArrayDef]:
    arrays: List[ArrayDef] = []
    for match in ARRAY_DECL_RE.finditer(text):
        ctype = match.group("ctype")
        name = match.group("name")
        dims_text = match.group("dims") or ""
        dims = parse_dims(dims_text)

        braced, _ = extract_braced(text, match.end() - 1)
        initializer = braced[1:-1]
        values = [int(x) for x in re.findall(r"-?\d+", initializer)]

        arrays.append(ArrayDef(name=name, ctype=ctype, dims=dims, values=values))
    return arrays


def to_hex(value: int, width: int) -> str:
    mask = (1 << width) - 1
    unsigned = value & mask
    hex_width = (width + 3) // 4
    return f"{unsigned:0{hex_width}X}"


def write_mem(path: str, values: Sequence[int], width: int) -> None:
    with open(path, "w", newline="\n") as f:
        for v in values:
            f.write(to_hex(v, width) + "\n")


def write_mif(path: str, values: Sequence[int], width: int) -> None:
    depth = len(values)
    addr_width = max(1, (depth - 1).bit_length())
    addr_hex_width = (addr_width + 3) // 4

    with open(path, "w", newline="\n") as f:
        f.write(f"WIDTH={width};\n")
        f.write(f"DEPTH={depth};\n")
        f.write("ADDRESS_RADIX=HEX;\n")
        f.write("DATA_RADIX=HEX;\n")
        f.write("CONTENT BEGIN\n")
        for addr, v in enumerate(values):
            f.write(f"    {addr:0{addr_hex_width}X} : {to_hex(v, width)};\n")
        f.write("END;\n")


def sanitize_name(name: str) -> str:
    clean = re.sub(r"[^A-Za-z0-9_]", "_", name)
    if re.match(r"^\d", clean):
        clean = "_" + clean
    return clean


def write_verilog_rom(
    path: str,
    array_def: ArrayDef,
    mem_filename: str,
    data_width: int,
    module_prefix: str,
    ramstyle: Optional[str],
) -> None:
    depth = len(array_def.values)
    addr_width = max(1, (depth - 1).bit_length())
    module_name = f"{module_prefix}{sanitize_name(array_def.name)}"

    dims_comment = "unknown"
    if array_def.dims:
        dims_comment = "][".join(str(d) for d in array_def.dims)

    with open(path, "w", newline="\n") as f:
        f.write("// Auto-generated by weights_to_mem.py\n")
        f.write(f"// Array: {array_def.name}\n")
        f.write(f"// Shape: [{dims_comment}]\n")
        f.write("// Flatten order: row-major (C order)\n\n")

        f.write(f"module {module_name} #(\n")
        f.write(f"    parameter integer ADDR_WIDTH = {addr_width},\n")
        f.write(f"    parameter integer DATA_WIDTH = {data_width},\n")
        f.write(f"    parameter integer DEPTH = {depth},\n")
        f.write(f"    parameter MEM_FILE = \"{mem_filename}\"\n")
        f.write(") (\n")
        f.write("    input  wire                    clk,\n")
        f.write("    input  wire [ADDR_WIDTH-1:0]   addr,\n")
        f.write("    output reg  signed [DATA_WIDTH-1:0] q\n")
        f.write(");\n\n")
        if ramstyle:
            f.write(f"    (* ramstyle = \"{ramstyle}\" *) reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];\n\n")
        else:
            f.write("    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];\n\n")
        f.write("    initial begin\n")
        f.write("        $readmemh(MEM_FILE, mem);\n")
        f.write("    end\n\n")
        f.write("    always @(posedge clk) begin\n")
        f.write("        q <= $signed(mem[addr]);\n")
        f.write("    end\n\n")
        f.write("endmodule\n")


def parse_only_list(values: Optional[List[str]]) -> Optional[List[str]]:
    if not values:
        return None
    result: List[str] = []
    for item in values:
        for part in item.split(","):
            part = part.strip()
            if part:
                result.append(part)
    return result or None


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Convert exported weights header to .mem/.mif and Verilog ROMs."
    )
    parser.add_argument(
        "--input",
        required=True,
        help="Path to exported weights header (e.g., tinylenet_weights.h)",
    )
    parser.add_argument(
        "--out-dir",
        default=".",
        help="Output directory for .mem/.mif and ROM .v files",
    )
    parser.add_argument(
        "--format",
        default="mem",
        help="Comma-separated list: mem,mif (default: mem)",
    )
    parser.add_argument(
        "--verilog",
        action="store_true",
        help="Generate Verilog ROM wrappers",
    )
    parser.add_argument(
        "--module-prefix",
        default="rom_",
        help="Prefix for generated Verilog module names (default: rom_)",
    )
    parser.add_argument(
        "--ramstyle",
        default="M9K",
        help="Quartus RAM style attribute value (default: M9K). Use '' or 'none' to omit.",
    )
    parser.add_argument(
        "--only",
        action="append",
        help="Only export specific arrays (repeat or comma-separated)",
    )
    parser.add_argument(
        "--list",
        action="store_true",
        help="List arrays found and exit",
    )

    args = parser.parse_args()
    fmt = {part.strip().lower() for part in args.format.split(",") if part.strip()}
    if not fmt:
        fmt = {"mem"}
    unknown = fmt - {"mem", "mif"}
    if unknown:
        raise ValueError(f"Unsupported format(s): {', '.join(sorted(unknown))}")
    if args.verilog and "mem" not in fmt:
        fmt.add("mem")

    with open(args.input, "r", encoding="utf-8", errors="ignore") as f:
        raw = f.read()
    text = strip_comments(raw)

    arrays = parse_arrays(text)
    if not arrays:
        print("No arrays found.")
        return 1

    only = parse_only_list(args.only)
    if only:
        arrays = [a for a in arrays if a.name in only]
        if not arrays:
            print("No arrays matched --only.")
            return 1

    if args.list:
        for a in arrays:
            dims = "x".join(str(d) for d in a.dims) if a.dims else "unknown"
            print(f"{a.name}: {a.ctype}, shape={dims}, count={len(a.values)}")
        return 0

    os.makedirs(args.out_dir, exist_ok=True)

    ramstyle = args.ramstyle.strip()
    if ramstyle.lower() == "none":
        ramstyle = ""

    for a in arrays:
        if a.ctype not in TYPE_WIDTHS:
            raise ValueError(f"Unsupported type {a.ctype} for array {a.name}")
        width = TYPE_WIDTHS[a.ctype]

        if a.dims:
            expected = product(a.dims)
            if expected != len(a.values):
                print(
                    f"Warning: {a.name} expected {expected} values, got {len(a.values)}"
                )

        base = a.name
        mem_path = os.path.join(args.out_dir, f"{base}.mem")
        if "mem" in fmt:
            write_mem(mem_path, a.values, width)
        if "mif" in fmt:
            mif_path = os.path.join(args.out_dir, f"{base}.mif")
            write_mif(mif_path, a.values, width)
        if args.verilog:
            mem_filename = os.path.basename(mem_path)
            verilog_path = os.path.join(args.out_dir, f"{base}_rom.v")
            write_verilog_rom(
                verilog_path,
                a,
                mem_filename,
                width,
                args.module_prefix,
                ramstyle if ramstyle else None,
            )

    print(f"Exported {len(arrays)} array(s) to {args.out_dir}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
